#### 5643. 将数组分成三个子数组的方案数

我们称一个分割整数数组的方案是**好的** ，当它满足：

* 数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。
* left 中元素和**小于等于** mid 中元素和，mid 中元素和**小于等于** right 中元素和。

给你一个**非负**整数数组 nums ，请你返回 **好的** 分割 nums 方案数目。由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

示例1、

> 输入：nums = [1,2,2,2,5,0]
> 输出：3
> 解释：nums 总共有 3 种好的分割方案：
> [1] [2] [2,2,5,0]
> [1] [2,2] [2,5,0]
> [1,2] [2,2] [5,0]

解题思路：

> 1、涉及连续数组和一般需要维护一个前缀和
>
> 2、如果暴力法就是C^2^ ~n-1~ ，根据提示：nums.length <= 10^5^ ，可知暴力肯定超时，需要优化。
>
> 3、本题需要先确定第一次分割的位置，然后再搜索寻找第二次分割的位置，由搜索可以联想到**二分查找**

步骤：

设第一次分割的位置为i，第二次分割的位置为j，则【0，i】为left，【i+1，j】为mid，【j+1，nums.length - 1】为right

> 1、首先确定**i**的位置，如果preSum[i] > preSum[nums.length - 1] / 3，则**j**无论在什么位置都无法完成分割，因此**i**的枚举到preSum[i] <= preSum[nums.length - 1] / 3
>
> 2、其次确定j的位置：
>
> 首先确定最小的位置，最小要满足：left == mid => preSum[i] * 2  = preSum[j] 
>
> if 存在 preSum[i] * 2  = preSum[j] 则返回 j
>
> if 不存在 则返回 满足preSum[j] ≤ preSum[i] * 2 ≤ preSum[j+1]
>
> 其次确定最大的位置，最大要满足：mid == right => preSum[j] ≤ preSum[i] + (preSum[n - 1] - preSum[i])/2

确定j的下界：

==注意==：由于bound是乘法得来，因此bound不会出现丢失小数点问题。

1、确定搜索范围

因此当preSum[mid] < bound时，j ≤ mid的值都会使得preSum[j] < bound，因此抛弃mid左边(==包括mid==) => left = mid + 1;

当preSum[mid] ≥ bound时，j ≥ mid 的值都会使得preSum[j] ≥ preSum[mid] ≥ bound，因此需要保留**mid** => right = mid

2、确定退出条件

right表示right**有可能**是j，当right**右边的一定不是**j，left表示left有可能是j，left左边的一定不是j

因此当**left == right**时，可以得出left一定是j，所以循环条件为left < right

>```java
>private int getLowerBound(int[] preSum,int left,int right,int bound) {
>        while (left < right) {
>            int mid = (right - left)/2 + left;
>            if (preSum[mid] < bound) {
>                left = mid + 1;
>            } else {
>                right = mid;
>            }
>        }
>        return left;
>}
>```

确定j的上界：

==注意==：由于bound是除法得来，可能会出现小数点丢失问题。

1、确定搜索范围

假设：当bound = 6.5时，bound会变为==6==

因此当preSum[mid] ≤ bound时，mid值可能为答案，mid左边的值一定不为答案

当preSum[mid] ＞ bound时，例如在假设中preSum[mid] = 7，不符合题意，因此mid右边的值(==包括mid==)一定不是答案

2、确定退出条件

right表示right**右边的（包括right）一定不是**j，left表示left有可能是j，但left左边的一定不是j

因此当**left == right**时，可以得出left - 1一定是j，所以循环条件为left < right

>```java
>private int getHigherBound(int[] preSum,int left,int right,int bound) {
>    while (left < right) {
>        int mid = (right - left)/2 + left;
>        if (preSum[mid] <= bound) {
>            left = mid + 1;
>        } else {
>            right = mid;
>        }
>    }
>    return left - 1;
>}
>```