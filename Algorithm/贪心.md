贪心算法：从**局部最优**推出**总体最优**

> ①建立数学模型来描述问题。
>
> ②把求解的问题分成若干个子问题 。
>
> ③对每个子问题求解，得到子问题的局部最优解。
>
> ④把子问题的解局部最优解合成原来解问题的一个解

### 一、翻转矩阵后的得分

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回**尽可能高**的分数。

示例：

> 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
> 输出：39
> 解释：
> 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
> 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

算法核心思路：

1、遍历行，通过行翻转，先保证每一行最大值 =>每行的第一个值为1

2、遍历列，通过列翻转，再保证每一列中1的个数最多

```java
class Solution {
    public int matrixScore(int[][] A) {
        for (int[] a : A) {
            if (a[0] == 0) {
                for (int i = 0; i < a.length; i++) {
                    a[i] = (a[i] == 0) ? 1 :0;//翻转行
                }
            }
        }

        int res = A.length * (int)Math.pow(2,A[0].length-1);
        //由于只返回最终结果，不需要翻转列，只需要根据1的个数计算值即可
        for (int i = 1; i < A[0].length;i++) {
            int oneCount = 0;
            for (int j = 0; j < A.length;j++) {
                oneCount += A[j][i];
            }
            oneCount = Math.max(oneCount,A.length - oneCount);
            res += oneCount * (int)Math.pow(2,A[0].length - i - 1);
        }
        return res;
    }
}
```

1642、可以到达的最远建筑

给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 **bricks** 和梯子 **ladders** 。

你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。

当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时：

* 如果当前建筑物的高度 ≥ 下一建筑物的高度，则不需要梯子或砖块

* 如果当前建筑的高度 ＜ 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块


如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。

**贪心**策略：**尽量**使用砖块填补高度差较小的楼层

> 1、使用**最小堆**存储经过的高度差
>
> 2、先使用梯子，梯子用完后，使用**砖块**替换堆中**最小的高度差**。

```java
class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        
        for (int i = 1; i < heights.length; i++) {
            if (heights[i] - heights[i - 1] > 0) {
                queue.offer(heights[i] - heights[i - 1]);
                if (ladders > 0) {
                    ladders--;
                } else {
                    Integer min = queue.poll();
                    if (bricks - min > 0) {
                        bricks -= min;
                    } else if (bricks - min == 0) {
                        return i;
                    } else {
                        return i - 1;
                    }
                }
            }
        }
        return heights.length;
    }
}
```



